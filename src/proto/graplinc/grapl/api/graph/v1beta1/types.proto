syntax = "proto3";

import "google/protobuf/wrappers.proto";

package graplinc.grapl.api.graph.v1beta1;

// The Session Identity Strategy is used to derive a canonical identity for any node that has a
// 'pseudo key', as well as a beginning, middle, and end.
// The 'pseudo key' can itself be multiple values concatenated together.
// As an example, a ProcessNode would have a pseudo key based on its hostname and pid,
// but because that combination is only unique while the process is alive, we also take into account
// the creation time of that process, when we've last seen it, and when it's terminated.
message Session {
    // Such as the pid + assetid
    repeated string primary_key_properties = 1;
    bool primary_key_requires_asset_id = 2;
    string created_time = 3;
    string last_seen_time = 4;
    string terminated_time = 5;
}

// The Static Identity Strategy is used when a node already has its own way of being uniquely identified.
// As one example, an AWS Resource Name uniquely identifies all AWS resources across accounts, so it would be
// a suitable Static identity.
message Static {
    repeated string primary_key_properties = 1;
    bool primary_key_requires_asset_id = 2;
}

message IdStrategy {
    oneof strategy {
        Session session = 1;
        Static static = 2;
    }
}

// NodeProperty not only denotes what primitive type the value should be treated as - such as u64, i64, string,
// but also the behavior of property merges. Because Grapl can not expect any kind of strict ordering of events
// within or across datasources every property has to define a merge function to resolve conflicts.
// *In general* these merges are idempotent and commutative, but not necessarily - for example, a string
// that gets set to the "first" value and then never changes is not commutative. This is actually OK, so long as  we
// have external knowledge of the datasources that informs us that the string will never change.
message NodeProperty {
    oneof property {
        // `increment_only_uint_prop` is an unsigned 64bit integer. On merge the larger value is stored.
        uint64 increment_only_uint_prop = 1;
        // `decrement_only_uint_prop` is an unsigned 64bit integer. On merge the smaller value is stored.
        uint64 decrement_only_uint_prop = 2;
        // `immutable_uint_prop` is an unsigned 64bit integer. On merge the old value is preserved.
        uint64 immutable_uint_prop = 3;
        // `increment_only_int_prop` is a signed 64bit integer. On merge the larger value is stored.
        int64 increment_only_int_prop = 4;
        // `decrement_only_int_prop` is a signed 64bit integer. On merge the smaller value is stored.
        int64 decrement_only_int_prop = 5;
        // `immutable_int_prop` is a signed 64bit integer. On merge the old value is preserved.
        int64 immutable_int_prop = 6;
        // `immutable_int_prop` is a utf8 encoded string. On merge the old value is preserved.
        string immutable_str_prop = 7;
    }
}

message NodeDescription {
    map<string, NodeProperty> properties = 1;
    string node_key = 2;
    string node_type = 3;
    repeated IdStrategy id_strategy = 4;
}

message IdentifiedNode {
    map<string, NodeProperty> properties = 1;
    string node_key = 2;
    string node_type = 3;
}

message MergedNode {
    map<string, NodeProperty> properties = 1;
    uint64 uid = 2;
    string node_key = 3;
    string node_type = 4;
}

message Edge {
    string from_node_key = 1;
    string to_node_key  = 2;
    string edgeName = 3;
}

message MergedEdge {
    string from_uid = 1;
    string from_node_key = 2;
    string to_uid = 3;
    string to_node_key = 4;
    string edgeName = 5;
}

message EdgeList {
    repeated Edge edges = 1;
}

message MergedEdgeList {
    repeated MergedEdge edges = 1;
}

message GraphDescription {
    map <string, NodeDescription> nodes = 1;
    map <string, EdgeList> edges = 2;
}

message IdentifiedGraph{
    map <string, IdentifiedNode> nodes = 1;
    map <string, EdgeList> edges = 2;
}

message MergedGraph{
    map <string, MergedNode> nodes = 1;
    map <string, MergedEdgeList> edges = 2;
}
